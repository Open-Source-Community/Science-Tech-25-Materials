# ðŸ§­ Lowest Common Ancestor (LCA) in C++ Using Euler Tour + RMQ (No Classes or Structs)

This guide explains how to compute the **Lowest Common Ancestor (LCA)** in a tree using an **Euler Tour** and **Range Minimum Query (RMQ)** with a **Sparse Table**, all in **plain C++ without using classes or structs**. The tree is represented as an adjacency list using `vector<vector<int>>`.

---

## ðŸ“Œ What is the LCA?

The **Lowest Common Ancestor (LCA)** of two nodes `u` and `v` in a tree is the **deepest node** that is an ancestor of both `u` and `v`. It's a fundamental operation in many tree-based algorithms and is commonly used in competitive programming and computer science research.

---

## ðŸ’¡ Overview of the Approach

We solve the LCA problem using:

1. **Euler Tour**: Traverse the tree and record:
   - Each node visit.
   - Depth of each node when visited.
   - First occurrence of each node in the tour.
2. **Range Minimum Query (RMQ)**: Use a Sparse Table to quickly query the node with minimum depth between any two positions in the Euler tour â€” this corresponds to the LCA.

This approach transforms the LCA problem into an RMQ problem.

---

## ðŸ§± Data Structures Used

- `tree`: adjacency list for representing the tree.
- `euler`: stores the order of visited nodes in the Euler tour.
- `depth`: depth of each node at time of visit in the Euler tour.
- `first_occurrence`: index of the first occurrence of each node in `euler`.
- `st[][]`: sparse table to perform range minimum queries on `depth`.
- `log_table[]`: precomputed floor of log base 2 values for fast queries.

---

## ðŸ”£ Full C++ Implementation

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 100005; // max number of nodes
const int LOG = 20;      // log2(MAXN)

vector<vector<int>> tree;
vector<int> euler, depth, first_occurrence;
int st[2 * MAXN][LOG];
int log_table[2 * MAXN];

// Perform DFS to generate Euler tour
void dfs(int node, int d, int parent) {
    first_occurrence[node] = euler.size();
    euler.push_back(node);
    depth.push_back(d);

    for (int child : tree[node]) {
        if (child != parent) {
            dfs(child, d + 1, node);
            euler.push_back(node);
            depth.push_back(d);
        }
    }
}

// Build sparse table over the depth array
void buildSparseTable() {
    int n = depth.size();

    log_table[1] = 0;
    for (int i = 2; i <= n; i++)
        log_table[i] = log_table[i / 2] + 1;

    for (int i = 0; i < n; i++)
        st[i][0] = i;

    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 0; i + (1 << j) <= n; i++) {
            int l = st[i][j - 1];
            int r = st[i + (1 << (j - 1))][j - 1];
            st[i][j] = (depth[l] < depth[r]) ? l : r;
        }
    }
}

// Query LCA of u and v
int lca(int u, int v) {
    int left = first_occurrence[u];
    int right = first_occurrence[v];
    if (left > right) swap(left, right);
    int j = log_table[right - left + 1];
    int l = st[left][j];
    int r = st[right - (1 << j) + 1][j];
    return (depth[l] < depth[r]) ? euler[l] : euler[r];
}

// Example usage
int main() {
    int n = 9; // number of nodes
    tree.resize(n);
    first_occurrence.resize(n);

    // Build tree
    tree[0] = {1, 2};
    tree[1] = {3, 4};
    tree[2] = {5, 6};
    tree[5] = {7, 8};

    // Step 1: Perform Euler tour starting from root
    dfs(0, 0, -1);

    // Step 2: Build RMQ over depth array
    buildSparseTable();

    // Step 3: Answer LCA queries
    int u = 4, v = 8;
    cout << "LCA of " << u << " and " << v << " is: " << lca(u, v) << endl;

    return 0;
}
